<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Search in Graph Theory | Sakeven&#39;s Blog</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Search in Graph Theory</span></h1>

<h2 class="date">2014/11/07</h2>

<p class="terms">
  
  
  Categories: <a href="/categories/algorithm">Algorithm</a> 
  
  
  
  Tags: <a href="/tags/acm">acm</a> <a href="/tags/graph-theory">graph theory</a> 
  
  
</p>
</div>

<main>


<p>搜索在图论中有着广泛的应用。许多图的问题需要遍历整个图，才能获得最优解。<br />
深度优先搜索和广度优先搜索是图论中最常用的两种搜索技巧。</p>

<h2 id="深度优先搜索-depth-first-search">深度优先搜索(Depth-First-Search)</h2>

<p>深度优先搜索，简称为&rdquo;dfs&rdquo;，所遵循的搜索策略是尽可能“深”地搜索。它的基本思想是：为了求得问题的解，先选择某一种可能情况向前（子结点）探索，在探索过程中，一旦发现原来的选择不符合要求，就回溯至父亲结点重新选择另一结点，继续向前探索，如此反复进行，直至求得最优解。深度优先搜索的实现方式可以采用递归或者栈来实现。深搜在求解图的连通性等问题上有着广泛的应用。</p>

<p>对图 <code>G</code> 进行深度优先搜索，会产生一个深度优先搜索树，在搜索时对顶点加上搜索的时间戳，这个搜索树会显现一些良好的性质，我们用 dfn 数组记录深度优先访问的某顶点的时间， visited 数组记录某顶点是否已经被访问过。</p>

<ol>
<li>从图 <code>G</code> 某一顶点 <code>v</code> 开始深度优先搜索过程：标记 <code>v</code> 已经被访问过，深度优先搜索 <code>v</code> 的邻接顶点 <code>u</code>；</li>
<li>然后递归地进行这一过程，直到此刻访问的顶点 <code>v</code> 没有邻接顶点或者它的邻接顶点已经全被标记过时，进行回溯。</li>
</ol>

<p>代码</p>

<pre><code class="language-c++">void dfs(int v) {
	visited[v] = true;
	dfn[v] = time++;
	
	// 依次访问顶点 v 的邻接顶点
	for(int i = head[v]; i != -1; i = edge[i].pre) {
		int u = edge[i].cur;
		if(visited[u] == fasle) {
			printf(&quot;%d &quot;, u);
			visited[u] = true;
			dfs(u);
		}
	}
}
</code></pre>

<p><img src="/img/graph_theory/dfs.jpg" alt="图 2.1" title="图 2.1" />
图 2.1 深搜图</p>

<p>深搜，某种意义上，可以称之为一种枚举，在不剪枝的情况下，会尽可能的搜索所有可能状态，直到找到解为止，时间复杂度通常呈几何速度增长。当深搜应用于图的遍历时，若图采用邻接表的储存形式，它的时间复杂度将是 <code>O(|E|)</code>。</p>

<h3 id="剪枝">剪枝</h3>

<p>剪枝不是某种特定算法。它是对于，在搜索算法上，排除某些搜索情况，减少大量无效分支的代码技巧的统称。就像一棵树，剪去不必要的枝条，以降低时间规模。</p>

<p>常见的剪枝技巧包括奇偶剪枝法。</p>

<h2 id="广度优先搜索-breadth-first-search">广度优先搜索（Breadth-First-Search）</h2>

<p>广度优先搜索，简称“bfs”，顾名思义，尽可能广地进行搜索。它的思想是从一个顶点开始，辐射状地优先遍历其周围较广的区域。</p>

<p>广度优先搜索使用队列来实现。</p>

<ol>
<li>初始化： 从图 <code>G</code> 某一顶点 <code>src</code> 开始，将其存入一个队列 <code>visit_queue</code>, 并标记 <code>v</code> 已经被访问过。</li>
<li>从队列弹出队首 <code>v</code>，依次访问顶点的邻接顶点 <code>u</code>，如果顶点 <code>u</code> 没有被访问过，则将 <code>u</code> 存入队列，并标记 <code>u</code> 已经被访问过，否则跳过该顶点 <code>u</code>；</li>
<li>重复过程 1 直到队列为空，此时所有顶点都被访问过，搜索结束。</li>
</ol>

<p>广度优先搜索通常用于迷宫问题，找出某点到某点的最短距离。由于广搜是分层的，离源点 <code>src</code> 越近其所在层次（depth）越低，其最短距离即是其所在层次数。</p>

<p>代码</p>

<pre><code class="language-c++">void bfs(int src) {
	queue&lt;int&gt; visit_queue;
	visit_queue.push(src);
	visited[src] = true;
	depth[src] = 0;

	while(visit_queue.empty() == false) {
		int v = visit_queue.front();
		visit_queue.pop();

		// 依次访问 v 的子节点
		for(int i = head[v]; i != -1; i = edge[i].pre) {
			int u = edge[i].cur;
			if(visited[u]) continue;

			depth[u] = depth[v] + 1;
			visit_queue.push(u);
			visited[u] = true;
			printf(&quot;%d &quot;, u);
		}
	}
}
</code></pre>

<p><img src="/img/graph_theory/bfs.jpg" alt="图 2.2" title="图 2.2" />
图 2.2 广搜图</p>

</main>

  <footer>
  <script>
(function() {
    var i, text, code, codes = document.getElementsByTagName('code');
    for (i = 0; i < codes.length;) {
      code = codes[i];
      if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
        text = code.textContent;
        if (/^\$[^$]/.test(text) && /[^$]\$$/.test(text)) {
          text = text.replace(/^\$/, '\\(').replace(/\$$/, '\\)');
          code.textContent = text;
        }
        if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
            /^\$(.|\s)+\$$/.test(text) ||
            /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
          code.outerHTML = code.innerHTML;  
          continue;
        }
      }
      i++;
    }
  })();  
</script>
<script async src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.12.0/languages/r.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.12.0/languages/go.min.js"></script>
<script>
hljs.initHighlightingOnLoad();
</script>
  
  <hr/>
  &copy; <a href="mailto:sakeven.jiang@gmail.com">Sakven Jiang</a> 2017 | <a href="https://github.com/sakeven">GitHub</a>
  
  </footer>
  </body>
</html>

