<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sakeven&#39;s Blog</title>
    <link>https://sakeven.me/</link>
    <description>Recent content on Sakeven&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 27 Aug 2017 22:42:00 +0800</lastBuildDate>
    
	<atom:link href="https://sakeven.me/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>RESTful API Design</title>
      <link>https://sakeven.me/2017/08/27/restful-api-design/</link>
      <pubDate>Sun, 27 Aug 2017 22:42:00 +0800</pubDate>
      
      <guid>https://sakeven.me/2017/08/27/restful-api-design/</guid>
      <description>之前有过多次面试别人的经历，大多简历上会写上使用 RESTful API 进行设计或者对其熟悉。然而问下来，却一知半解。 如果有读者不了解 RESTful API，可以先看看这篇。</description>
    </item>
    
    <item>
      <title>Create a Hugo Site</title>
      <link>https://sakeven.me/2017/08/27/create-a-hugo-site/</link>
      <pubDate>Sun, 27 Aug 2017 14:58:00 +0800</pubDate>
      
      <guid>https://sakeven.me/2017/08/27/create-a-hugo-site/</guid>
      <description>最近觉得把工作、学习、生活中的一些事情记录下来比较好，于是昨天花了一个下午搭个人博客。 用的 Hugo，这篇记录下过程。 安装 官方教程提供的是 brew install</description>
    </item>
    
    <item>
      <title>Kubernetes Scheduler</title>
      <link>https://sakeven.me/2017/08/02/kubernetes-scheduler/</link>
      <pubDate>Wed, 02 Aug 2017 18:10:00 +0800</pubDate>
      
      <guid>https://sakeven.me/2017/08/02/kubernetes-scheduler/</guid>
      <description>目标 公平：如何保证每个节点都能被分配资源 资源高效利用：集群所有资源最大化使用 效率：调度的性能要好，能够尽快地对大批量的 Pod 完成调度工作 灵活：允</description>
    </item>
    
    <item>
      <title>Kubernetes QoS</title>
      <link>https://sakeven.me/2017/07/30/kubernetes-qos/</link>
      <pubDate>Sun, 30 Jul 2017 18:10:00 +0800</pubDate>
      
      <guid>https://sakeven.me/2017/07/30/kubernetes-qos/</guid>
      <description>Pod 的 QoS 分为三个级别：Guaranteed、Burstable、BestEffort。 其等级划分与 Pod 的资源（CPU、内存）要求有关： BestEffort 当 Pod 中的</description>
    </item>
    
    <item>
      <title>The Art of Exploitation</title>
      <link>https://sakeven.me/2016/05/10/the-art-of-exploitation/</link>
      <pubDate>Tue, 10 May 2016 22:37:04 +0800</pubDate>
      
      <guid>https://sakeven.me/2016/05/10/the-art-of-exploitation/</guid>
      <description>1. 栈保护 在函数内有这样一段汇编： 0x000000000040055d &amp;lt;+0&amp;gt;: push rbp 0x000000000040055e &amp;lt;+1&amp;gt;: mov rbp,rsp 0x0000000000400561 &amp;lt;+4&amp;gt;: sub rsp,0x50 . . . 0x0000000000400575 &amp;lt;+24&amp;gt;: mov rax,QWORD PTR fs:0x28 0x000000000040057e &amp;lt;+33&amp;gt;: mov QWORD PTR [rbp-0x8],rax . . . 0x000000000040058f &amp;lt;+50&amp;gt;: mov rax,QWORD PTR [rbp-0x8] 0x0000000000400593 &amp;lt;+54&amp;gt;: xor rax,QWORD PTR fs:0x28 0x000000000040059c &amp;lt;+63&amp;gt;: je 0x4005a3 &amp;lt;test_function+70&amp;gt; 0x000000000040059e &amp;lt;+65&amp;gt;: call 0x400440 &amp;lt;__stack_chk_fail@plt&amp;gt; 0x00000000004005a3 &amp;lt;+70&amp;gt;:</description>
    </item>
    
    <item>
      <title>GDB</title>
      <link>https://sakeven.me/2016/05/09/gdb/</link>
      <pubDate>Mon, 09 May 2016 15:18:01 +0800</pubDate>
      
      <guid>https://sakeven.me/2016/05/09/gdb/</guid>
      <description>设置 intel 格式汇编 在 ~/.gdbinit中： set disassembly intel 查看寄存器 (gdb) i r rax 0x4005a5 4195749 rbx 0x0 0 rcx 0x0 0 rdx 0x7fffffffe628 140737488348712 rsi 0x7fffffffe618 140737488348696 rdi 0x1 1 rbp 0x7fffffffe530 0x7fffffffe530 rsp 0x7fffffffe530 0x7fffffffe530 r8 0x7ffff7dd4e80 140737351863936 r9 0x7ffff7dea560 140737351951712 r10 0x7fffffffe3c0 140737488348096 r11 0x7ffff7a36dd0 140737348070864 r12 0x400470 4195440</description>
    </item>
    
    <item>
      <title>Qemu Install</title>
      <link>https://sakeven.me/2016/04/29/qemu-install/</link>
      <pubDate>Fri, 29 Apr 2016 15:08:36 +0800</pubDate>
      
      <guid>https://sakeven.me/2016/04/29/qemu-install/</guid>
      <description>qemu 在 ubuntu 14.04 下安装 qemu 的 README.md 写的安装方式过于简略。实际上 qemu 的编译安装比较麻烦，需要下载一些依赖。 以下是安装依赖，并配置编译安装 qemu 到 /usr/local/bin wget http://wiki.qemu-project.org/download/qemu-2.6.0-rc3.tar.bz2 tar jxvf qemu-2.6.0-rc3.tar.bz2 cd qemu-2.6.0-rc3/ sudo</description>
    </item>
    
    <item>
      <title>ShadowSocks Analysis</title>
      <link>https://sakeven.me/2016/04/28/shadowsocks-analysis/</link>
      <pubDate>Thu, 28 Apr 2016 21:32:52 +0800</pubDate>
      
      <guid>https://sakeven.me/2016/04/28/shadowsocks-analysis/</guid>
      <description>Socks5 协议 Socks5 是一种代理协议，常见的还有 http/https、socks4 代理。支持 TCP/UDP。 基于 TCP 的 socks5 1. 客户端向代理发送请求进行协商认证：</description>
    </item>
    
    <item>
      <title>CFS Scheduler [译]</title>
      <link>https://sakeven.me/2015/10/29/cfs-scheduler-%E8%AF%91/</link>
      <pubDate>Thu, 29 Oct 2015 19:00:00 +0800</pubDate>
      
      <guid>https://sakeven.me/2015/10/29/cfs-scheduler-%E8%AF%91/</guid>
      <description>原文：CFS Scheduler 1. 概览 CFS 意为 “完全公平调度器”，是一种新的“桌面”进程调度器，由 Ingo Molnar 实现，在 linux 2.6.23 中并入内核。 它是对之前的 vanilla 调度器的分时调度策略</description>
    </item>
    
    <item>
      <title>Linux Command</title>
      <link>https://sakeven.me/2015/08/28/linux-command/</link>
      <pubDate>Fri, 28 Aug 2015 19:00:00 +0800</pubDate>
      
      <guid>https://sakeven.me/2015/08/28/linux-command/</guid>
      <description>echo： 输出一段字符串 与通配符使用可以输出当前目录下的制定文件 find： 查找文件，基本格式 find [目录] [选项] [操作]，如 find . -name &#39;*.go&#39;</description>
    </item>
    
    <item>
      <title>File Stat</title>
      <link>https://sakeven.me/2015/06/25/file-stat/</link>
      <pubDate>Thu, 25 Jun 2015 19:00:00 +0800</pubDate>
      
      <guid>https://sakeven.me/2015/06/25/file-stat/</guid>
      <description>查看文件信息 #include &amp;lt;sys/stat.h&amp;gt; int fstat(int filedes, struct stat *buf)); int lstat(const char *pathname, struct stat *buf); int stat(const char *pathname, struct stat *buf); st_mode，文件模式字。 文件类型（S_IFMT）： 普通文件 S_ISREG(m) 目录文件 S_ISDIR(m) 块特殊文件</description>
    </item>
    
    <item>
      <title>Start of Hello World</title>
      <link>https://sakeven.me/2014/11/30/start-of-hello-world/</link>
      <pubDate>Sun, 30 Nov 2014 23:50:00 +0800</pubDate>
      
      <guid>https://sakeven.me/2014/11/30/start-of-hello-world/</guid>
      <description>#include &amp;lt;stdio.h&amp;gt; static __attribute__((constructor)) void before() { printf(&amp;quot;Hello&amp;quot;); } static __attribute__((destructor)) void after() { printf(&amp;quot; World!\n&amp;quot;); } int main(int args, char ** argv) { return 0; } 主函数没有任何函数调用，但是输出了 &amp;ldquo;Hello World!&amp;rdquo; 。Why? Answer: 最近去看了下 printf 函数的定义，在 macOS 10.10 中是</description>
    </item>
    
    <item>
      <title>Function Pointer</title>
      <link>https://sakeven.me/2014/11/08/function-pointer/</link>
      <pubDate>Sat, 08 Nov 2014 21:00:00 +0800</pubDate>
      
      <guid>https://sakeven.me/2014/11/08/function-pointer/</guid>
      <description>定义 函数指针是指向函数的指针。 函数指针的声明方法为： 返回值类型 ( * 指针变量名) ([形参列表]); 如： int (*proc)(int); // 声明函数指针 proc 使用 #include &amp;lt;stdio.h&amp;gt; int add(int, int); // 函数</description>
    </item>
    
    <item>
      <title>Search in Graph Theory</title>
      <link>https://sakeven.me/2014/11/07/search-in-graph-theory/</link>
      <pubDate>Fri, 07 Nov 2014 19:01:00 +0800</pubDate>
      
      <guid>https://sakeven.me/2014/11/07/search-in-graph-theory/</guid>
      <description>搜索在图论中有着广泛的应用。许多图的问题需要遍历整个图，才能获得最优解。 深度优先搜索和广度优先搜索是图论中最常用的两种搜索技巧。 深度优先搜索</description>
    </item>
    
    <item>
      <title>Basic Concept of Graph Theory</title>
      <link>https://sakeven.me/2014/11/07/basic-concept-of-graph-theory/</link>
      <pubDate>Fri, 07 Nov 2014 19:00:00 +0800</pubDate>
      
      <guid>https://sakeven.me/2014/11/07/basic-concept-of-graph-theory/</guid>
      <description>1.1 什么是图 我们首先需要知道什么是图，才能开始讨论图的性质和算法。这里说的图是一幅像梵高画的《星空》那样的图画么？还是百度地图呢？都不是，那它</description>
    </item>
    
    <item>
      <title>Go Style Guide</title>
      <link>https://sakeven.me/2014/10/19/go-style-guide/</link>
      <pubDate>Sun, 19 Oct 2014 19:00:00 +0800</pubDate>
      
      <guid>https://sakeven.me/2014/10/19/go-style-guide/</guid>
      <description>本篇讲的是 Go 代码风格，翻译自 CodeReviewComments。 版权 如何在程序中使用 GNU 许可证 无论使用哪种许可证，使用时需要在每个程序的源文</description>
    </item>
    
    <item>
      <title>Bitwise</title>
      <link>https://sakeven.me/2014/04/06/bitwise/</link>
      <pubDate>Sun, 06 Apr 2014 19:17:00 +0800</pubDate>
      
      <guid>https://sakeven.me/2014/04/06/bitwise/</guid>
      <description>大小写互相转换 如果仔细观察 ASCII 码表的话，就可以发现大小写字母的二进制表示中第 5 位相差一个 1 。于是大小写转换可以写成如下： void ch(char *c) { *c = (*c) ^ (1&amp;lt;&amp;lt;5); } 计</description>
    </item>
    
    <item>
      <title>Prime</title>
      <link>https://sakeven.me/2013/10/24/prime/</link>
      <pubDate>Thu, 24 Oct 2013 19:00:00 +0800</pubDate>
      
      <guid>https://sakeven.me/2013/10/24/prime/</guid>
      <description>〇. 素数的性质 素数只能被 1 和它本身整除。 一. 素数的普通算法 最朴素的素数测试，试除法，依次检验 \( 1-\sqrt n \) 能否整除 n bool is_prime(int n) { if(n % 2== 0 &amp;amp;&amp;amp; n != 2) return false; for(int</description>
    </item>
    
    <item>
      <title>About Me</title>
      <link>https://sakeven.me/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sakeven.me/about/</guid>
      <description>我就是我，颜色不一样的烟火。 18k 围棋棋士，喜欢睡觉，喜欢美食，拒绝闯红灯。 目前任职于 DaoCloud，高级开发工程师、开源工程师、产品经理，曾</description>
    </item>
    
  </channel>
</rss>